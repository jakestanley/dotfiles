#!/bin/sh
set -eu

# Block pushes that contain commits dated in the future (based on committer date).
#
# Bypass:
#   ALLOW_FUTURE_DATED_COMMITS=1 git push
#
# Allow small clock skew (seconds):
#   GIT_FUTURE_DATED_COMMIT_TOLERANCE_SECONDS=300

if [ "${ALLOW_FUTURE_DATED_COMMITS:-}" = "1" ]; then
  exit 0
fi

remote_name="${1:-}"
tolerance="${GIT_FUTURE_DATED_COMMIT_TOLERANCE_SECONDS:-300}"

case "$tolerance" in
  ''|*[!0-9]*)
    tolerance=300
    ;;
esac

now="$(date +%s)"
cutoff=$((now + tolerance))

null_sha="0000000000000000000000000000000000000000"
blocked=0

while read -r local_ref local_sha remote_ref remote_sha; do
  # Deleting a ref; nothing to check.
  if [ "$local_sha" = "$null_sha" ]; then
    continue
  fi

  commits=""
  if [ "${remote_sha:-$null_sha}" = "$null_sha" ]; then
    # New branch/tag on remote. Prefer checking commits not already on that remote.
    if [ -n "$remote_name" ]; then
      commits="$(git rev-list "$local_sha" --not --remotes="$remote_name" 2>/dev/null || true)"
    fi
    if [ -z "$commits" ]; then
      commits="$(git rev-list "$local_sha")"
    fi
  else
    commits="$(git rev-list "${remote_sha}..${local_sha}")"
  fi

  for sha in $commits; do
    ts="$(git show -s --format=%ct "$sha")"
    if [ "$ts" -gt "$cutoff" ]; then
      subject="$(git show -s --format=%s "$sha")"
      when="$(git show -s --format=%cI "$sha")"
      printf '%s\n' "error: future-dated commit detected; push blocked" >&2
      printf '%s\n' "  commit:  $sha" >&2
      printf '%s\n' "  date:    $when" >&2
      printf '%s\n' "  subject: $subject" >&2
      blocked=1
    fi
  done
done

if [ "$blocked" -ne 0 ]; then
  printf '%s\n' "" >&2
  printf '%s\n' "Fix the commit timestamp (amend/rebase), then push again." >&2
  printf '%s\n' "Bypass once with: ALLOW_FUTURE_DATED_COMMITS=1 git push" >&2
  printf '%s\n' "Clock skew tolerance (seconds): GIT_FUTURE_DATED_COMMIT_TOLERANCE_SECONDS=${tolerance}" >&2
  exit 1
fi

exit 0

